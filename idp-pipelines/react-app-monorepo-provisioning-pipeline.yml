# idp-pipelines/react-app-monorepo-provisioning-pipeline.yml
pipeline:
  name: E2E React App Provisioning
  identifier: E2E_React_App_Provisioning
  projectIdentifier: parson
  orgIdentifier: sandbox
  tags: {}
  stages:
    - stage:
        name: Create Jira
        identifier: Create_Jira
        description: ""
        type: Approval
        spec:
          execution:
            steps:
              - step:
                  name: Create Jira
                  identifier: Create_Jira
                  type: JiraCreate
                  timeout: 5m
                  spec:
                    connectorRef: account.Harness_JIRA
                    projectKey: HD
                    issueType: Story
                    fields:
                      - name: Summary
                        value: Testing - parson - <+pipeline.sequenceId>
        tags: {}
        when:
          pipelineStatus: Success
          condition: <+pipeline.variables.enable_jira> == "true"
    - stage:
        name: App Provisioner
        identifier: App_Provisioner
        description: ""
        type: IDP
        spec:
          infrastructure:
            type: KubernetesDirect
            spec:
              connectorRef: parsoneks
              namespace: harness-delegate-ng
              automountServiceAccountToken: true
              nodeSelector: {}
              os: Linux
          execution:
            steps:
              - step:
                  type: Run
                  name: Derive Vars
                  identifier: Derive_Vars
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner:latest
                    shell: Bash
                    command: |-
                      set -euo pipefail

                      env
                      echo ""
                      echo ""

                      ###############################################################################
                      # 1) Pass-throughs / normalization
                      ###############################################################################
                      GH_TOKEN="<+pipeline.variables.gh_token>"
                      GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      : "${GH_ORG:?GH_ORG is required}"
                      : "${MONOREPO_REPO:?MONOREPO_REPO is required}"
                      : "${PROJECT_SLUG:?PROJECT_SLUG is required}"

                      DEFAULT_BRANCH="${DEFAULT_BRANCH:-main}"
                      OWNER_TEAM="${OWNER_TEAM:-platform-team}"
                      PROJECT_OWNER="${PROJECT_OWNER:-}"
                      REQUESTOR_GH_USERNAME="${REQUESTOR_GH_USERNAME:-}"
                      TESTING="${TESTING:-no}"
                      GIT_AUTHOR_NAME="${GIT_AUTHOR_NAME:-Harness IDP Bot}"
                      GIT_AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-idp-bot@users.noreply.github.com}"

                      ###############################################################################
                      # 2) Computed values (idempotent)
                      ###############################################################################
                      WORKSPACE="${HARNESS_WORKSPACE:-/harness}"
                      REPO_DIR="${WORKSPACE}/${MONOREPO_REPO}"

                      # If FEATURE_BRANCH is provided, use it; else derive from prefix + sequenceId
                      NEW_BRANCH_PREFIX="${NEW_BRANCH_PREFIX:-feature}"
                      SEQ="<+pipeline.sequenceId>"
                      FEATURE_BRANCH="${FEATURE_BRANCH:-${NEW_BRANCH_PREFIX}/${PROJECT_SLUG}-${SEQ}}"

                      SRC_DIR="${REPO_DIR}/${PROJECT_SLUG}"               # cookiecutter output dir
                      DST_NAME="${DST_NAME:-${PROJECT_SLUG}}"             # target subfolder in mono
                      APP_PATH="/${DST_NAME}/"

                      BASE_URL="https://github.com/${GH_ORG}/${MONOREPO_REPO}"
                      BRANCH_URL="${BASE_URL}/tree/${FEATURE_BRANCH}"

                      ###############################################################################
                      # 3) Export for downstream steps (Harness reads these as outputs)
                      ###############################################################################
                      export GH_TOKEN GITHUB_TOKEN
                      export GH_ORG MONOREPO_REPO DEFAULT_BRANCH NEW_BRANCH_PREFIX
                      export PROJECT_SLUG OWNER_TEAM REQUESTOR_GH_USERNAME TESTING
                      export GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
                      export WORKSPACE REPO_DIR SRC_DIR DST_NAME APP_PATH
                      export FEATURE_BRANCH BASE_URL BRANCH_URL
                      export PROJECT_OWNER
                      echo "Derived variables ready."
                    envVariables:
                      GH_ORG: <+pipeline.variables.gh_org>
                      MONOREPO_REPO: <+pipeline.variables.base_repo>
                      DEFAULT_BRANCH: <+pipeline.variables.default_branch>
                      NEW_BRANCH_PREFIX: <+pipeline.variables.new_branch_prefix>
                      FEATURE_BRANCH: ""
                      PROJECT_SLUG: <+pipeline.variables.project_slug>
                      OWNER_TEAM: <+pipeline.variables.github_team>
                      REQUESTOR_GH_USERNAME: <+pipeline.variables.github_username>
                      TESTING: <+pipeline.variables.testing>
                      GIT_AUTHOR_NAME: Harness IDP Bot
                      GIT_AUTHOR_EMAIL: idp-bot@users.noreply.github.com
                      PROJECT_OWNER: <+pipeline.variables.project_owner>
                    outputVariables:
                      - name: GH_ORG
                      - name: MONOREPO_REPO
                      - name: DEFAULT_BRANCH
                      - name: NEW_BRANCH_PREFIX
                      - name: PROJECT_SLUG
                      - name: OWNER_TEAM
                      - name: REQUESTOR_GH_USERNAME
                      - name: TESTING
                      - name: GIT_AUTHOR_NAME
                      - name: GIT_AUTHOR_EMAIL
                      - name: WORKSPACE
                      - name: REPO_DIR
                      - name: SRC_DIR
                      - name: DST_NAME
                      - name: APP_PATH
                      - name: FEATURE_BRANCH
                      - name: BASE_URL
                      - name: BRANCH_URL
                      - name: PROJECT_OWNER
              - step:
                  type: Run
                  name: Verify Requester Access
                  identifier: Verify_Requester_Access
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner:latest
                    shell: Bash
                    command: |-
                      set -euo pipefail

                      # Make both gh CLI & curl happy regardless of which var a call expects
                      export GH_TOKEN="<+pipeline.variables.gh_token>"
                      export GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      OWNER="${GH_ORG}"
                      REPO="${MONOREPO_REPO}"
                      USERNAME="${REQUESTOR_GH_USERNAME}"
                      ENFORCE="<+pipeline.variables.enforce_requestor_access>"

                      : "${GITHUB_TOKEN:?Missing GITHUB_TOKEN}"
                      API="https://api.github.com"

                      if [[ -z "${USERNAME}" || "${USERNAME}" == "null" ]]; then
                        echo "‚ö†Ô∏è  No github_username provided via workflow. Skipping strict permission check."
                        CAN_COMMIT="false"
                        CAN_CREATE_PR="false"
                        PERMISSION="unknown"
                        export CAN_COMMIT CAN_CREATE_PR PERMISSION
                        if [[ "${ENFORCE}" == "yes" ]]; then
                          echo "‚ùå Enforcement on, but username missing. Provide github_username or set enforce_requestor_access=no."
                          exit 21
                        fi
                        exit 0
                      fi

                      echo "üîé Checking permissions for @$USERNAME on ${OWNER}/${REPO} ..."
                      # Repo info (for fork policy)
                      REPO_JSON="$(curl -fsS -H "Authorization: token $GITHUB_TOKEN" "$API/repos/$OWNER/$REPO")"
                      ALLOW_FORKING="$(echo "$REPO_JSON" | jq -r '.allow_forking // false')"

                      # User's effective permission (collaborator/team/org)
                      PERM_JSON="$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API/repos/$OWNER/$REPO/collaborators/$USERNAME/permission")"
                      if [[ -z "$PERM_JSON" || "$(echo "$PERM_JSON" | jq -r '.message // empty')" == "Not Found" ]]; then
                        PERMISSION="none"
                      else
                        PERMISSION="$(echo "$PERM_JSON" | jq -r '.permission // "none"')"
                      fi

                      CAN_COMMIT="false"
                      CAN_CREATE_PR="false"

                      case "$PERMISSION" in
                        admin|maintain|write)
                          CAN_COMMIT="true"
                          CAN_CREATE_PR="true"
                          ;;
                        triage|read|none|*)
                          CAN_COMMIT="false"
                          if [[ "$ALLOW_FORKING" == "true" ]]; then
                            # With read access, user can open PRs from a fork (if org policy allows forks)
                            CAN_CREATE_PR="true"
                          else
                            CAN_CREATE_PR="false"
                          fi
                          ;;
                      esac

                      echo "   permission: $PERMISSION"
                      echo "   allow_forking: $ALLOW_FORKING"
                      echo "   can_commit: $CAN_COMMIT"
                      echo "   can_create_pr: $CAN_CREATE_PR"

                      # Export for downstream use (optional)
                      export CAN_COMMIT="$CAN_COMMIT"
                      export CAN_CREATE_PR="$CAN_CREATE_PR"
                      export PERMISSION="$PERMISSION"

                      # Enforce policy if requested
                      if [[ "$ENFORCE" == "yes" && "$CAN_COMMIT" != "true" ]]; then
                        echo "‚ùå @$USERNAME lacks write access to ${OWNER}/${REPO} (perm=$PERMISSION)."
                        echo "   Add them to a team with write access, or set enforce_requestor_access=no to warn-only."
                        exit 20
                      fi

                      echo "‚úÖ Access gate passed (enforce=$ENFORCE)."
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                    outputVariables:
                      - name: CAN_COMMIT
                      - name: CAN_CREATE_PR
                      - name: PERMISSION
              - step:
                  type: GitClone
                  name: Clone Repo
                  identifier: Clone_Repo
                  spec:
                    connectorRef: parsonghharnessidpsandbox
                    repoName: <+pipeline.variables.base_repo>
                    cloneDirectory: /harness/<+pipeline.variables.base_repo>
                    build:
                      type: branch
                      spec:
                        branch: <+pipeline.variables.default_branch>
              - step:
                  type: Run
                  name: Create Branch
                  identifier: Create_Branch
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner:latest
                    shell: Bash
                    command: |-
                      #!/usr/bin/env bash
                      set -euo pipefail

                      export CONNECTOR_REF="<+pipeline.stages.App_Provisioner.spec.execution.steps.Clone_Repo.spec.connectorRef>"

                      # Make both gh CLI & curl happy regardless of which var a call expects
                      export GH_TOKEN="<+pipeline.variables.gh_token>"
                      export GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      # Workspace & repo paths
                      WORKSPACE="${HARNESS_WORKSPACE:-/harness}"
                      REPO_DIR="$WORKSPACE/$MONOREPO_REPO"

                      # Helpful computed paths
                      SRC_DIR="${SRC_DIR:-$WORKSPACE/$PROJECT_SLUG}"   # cookiecutter output
                      DST_NAME="${DST_NAME:-$PROJECT_SLUG}"            # monorepo subfolder
                      APP_PATH="/${DST_NAME}/"

                      # permissive ownership + safe dir
                      command -v sudo >/dev/null 2>&1 && sudo chown -R "$(id -u)":"$(id -g)" "$REPO_DIR" || true
                      git config --global --add safe.directory "$REPO_DIR" || true

                      cd "$REPO_DIR"

                      git fetch --no-tags origin "$DEFAULT_BRANCH" --depth 1 || true
                      git switch -C "$DEFAULT_BRANCH" "origin/$DEFAULT_BRANCH" >/dev/null 2>&1 || git switch "$DEFAULT_BRANCH"
                      git switch -c "$FEATURE_BRANCH"

                      # ensure origin can push
                      ORIGIN_URL="$(git remote get-url origin)"
                      case "$ORIGIN_URL" in
                        https://*@*) : ;;
                        https://*) git remote set-url origin "$(echo "$ORIGIN_URL" | sed -E 's#https://#https://oauth2:'"$GH_TOKEN"'@#')" ;;
                        git@*) SSH_PATH="$(echo "$ORIGIN_URL" | sed -E 's#^git@[^:]+:(.+)\.git#\1#')"
                              git remote set-url origin "https://oauth2:${GH_TOKEN}@github.com/${SSH_PATH}.git" ;;
                      esac

                      if [[ "${TESTING}" == "yes" ]]; then
                        echo "# IDP Testing Branch" > IDP_TESTING_README.md
                        echo "This branch was seeded by the Harness IDP pipeline in testing mode." >> IDP_TESTING_README.md
                        git -c user.name="${GIT_AUTHOR_NAME}" -c user.email="${GIT_AUTHOR_EMAIL}" add IDP_TESTING_README.md
                        git -c user.name="${GIT_AUTHOR_NAME}" -c user.email="${GIT_AUTHOR_EMAIL}" commit -m "chore(idp:test): seed testing branch [skip ci]"
                      fi

                      git push -u origin "$FEATURE_BRANCH"

                      CLEAN_REMOTE="$(git remote get-url origin | sed 's#https://[^@]*@#https://#')"
                      export BASE_URL="$CLEAN_REMOTE"
                      export BRANCH_URL="${CLEAN_REMOTE%.git}/tree/${FEATURE_BRANCH}"
                      export REPO_NAME="$MONOREPO_REPO"
                      export BRANCH_NAME="$FEATURE_BRANCH"
                      export REPO_DIR="$REPO_DIR"   # already defined above
                      echo "‚úÖ Branch created: ${CLEAN_REMOTE%.git}/tree/${FEATURE_BRANCH}"
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                    outputVariables:
                      - name: BRANCH_URL
                      - name: BASE_URL
                      - name: REPO_NAME
                      - name: BRANCH_NAME
                      - name: REPO_DIR
                      - name: CONNECTOR_REF
              - step:
                  type: CookieCutter
                  name: Scaffold Repo
                  identifier: Scaffold_Repo
                  spec:
                    templateType: public
                    publicTemplateUrl: https://github.com/harness-idp-sandbox/app-template-react-monorepo.git
                    outputDirectory: /harness/<+pipeline.variables.base_repo>
                    cookieCutterVariables:
                      project_name: <+pipeline.variables.project_name>
                      project_slug: <+pipeline.variables.project_slug>
                      project_owner: <+pipeline.variables.project_owner>
                      project_description: <+pipeline.variables.project_description>
                      github_org: <+pipeline.variables.gh_org>
                      github_repo: <+pipeline.variables.project_slug>
                      environment_name: <+pipeline.variables.environment_name>
                      aws_region: <+pipeline.variables.aws_region>
                      github_team: <+pipeline.variables.github_team>
                      github_monorepo: <+pipeline.variables.base_repo>
                      connector_ref: <+pipeline.variables.connector_ref>
                    verbose: false
                    overwriteIfExists: false
              - step:
                  type: DirectPush
                  name: Push to Branch
                  identifier: DirectPush_1
                  spec:
                    connectorType: Github
                    connectorRef: parsonghharnessidpsandbox
                    organization: <+pipeline.variables.gh_org>
                    repository: <+pipeline.variables.base_repo>
                    codeDirectory: /harness/<+pipeline.variables.base_repo>
                    branch: <+pipeline.variables.new_branch_prefix>/<+pipeline.variables.project_slug>-<+pipeline.sequenceId>
                  when:
                    stageStatus: Success
                    condition: <+pipeline.variables.testing> == "no"
              - step:
                  type: Run
                  name: Open Pull Request
                  identifier: Open_PR
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner:latest
                    shell: Bash
                    command: |-
                      #!/usr/bin/env bash
                      set -euo pipefail

                      echo <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      echo <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      echo <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      echo <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>/catalog-info.yaml

                      # Make both gh CLI & curl happy regardless of which var a call expects
                      export GH_TOKEN="<+pipeline.variables.gh_token>"
                      export GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      OWNER="${GH_ORG}"
                      REPO="${MONOREPO_REPO}"
                      BASE="${DEFAULT_BRANCH}"
                      HEAD="${FEATURE_BRANCH}"

                      # Workspace & repo paths
                      WORKSPACE="${HARNESS_WORKSPACE:-/harness}"
                      REPO_DIR="${REPO_DIR:-$WORKSPACE/$MONOREPO_REPO}"
                      SRC_DIR="${SRC_DIR:-$REPO_DIR/$PROJECT_SLUG}"   
                      DST_NAME="${DST_NAME:-$PROJECT_SLUG}"
                      APP_PATH="/${DST_NAME}/"

                      echo "=== Preflight ==="
                      echo "Repo: $OWNER/$REPO"
                      echo "Base (PR target): $BASE"
                      echo "Head (feature):   $HEAD"

                      ls -la /harness
                      ls -la $REPO_DIR
                      ls -la $SRC_DIR

                      gh --version || { echo "gh missing"; exit 1; }
                      jq --version || { echo "jq missing"; exit 1; }
                      curl --version >/dev/null 2>&1 || { echo "curl missing"; exit 1; }

                      # Verify repo & branches exist
                      curl -fsS -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$OWNER/$REPO" >/dev/null
                      curl -fsS -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$OWNER/$REPO/branches/$BASE"  >/dev/null
                      curl -fsS -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/$OWNER/$REPO/branches/$HEAD"  >/dev/null

                      TITLE="feat(idp:<+pipeline.sequenceId>): scaffold ${PROJECT_SLUG}"
                      TEMPLATE_PATH="$REPO_DIR/.github/pull_request_template.md"

                      # Ensure labels exist (no-op if already present)
                      ensure_label() {
                        local name="$1" color="$2" desc="$3"
                        # GET /repos/{owner}/{repo}/labels/{name} returns 404 if missing
                        if ! gh api "repos/$OWNER/$REPO/labels/$name" >/dev/null 2>&1; then
                          gh api -X POST "repos/$OWNER/$REPO/labels" \
                            -f name="$name" -f color="$color" -f description="$desc" >/dev/null || true
                        fi
                      }

                      # Core palette
                      ensure_label "idp"        "BFD4F2" "Created by Harness IDP"
                      ensure_label "scaffold"   "1D76DB" "Scaffolded code"
                      ensure_label "automation" "5319E7" "Automated change"
                      [[ "${TESTING}" == "yes" ]] && ensure_label "testing" "0E8A16" "Testing run"

                      # Change-management palette (created here, used later)
                      ensure_label "change:pending"  "FBCA04" "Awaiting ServiceNow change approval"
                      ensure_label "change:approved" "0E8A16" "ServiceNow change approved"
                      ensure_label "change:rejected" "D93F0B" "ServiceNow change rejected"

                      # Build a human-friendly identity string
                      if [[ -n "$REQUESTOR_GH_USERNAME" && "$REQUESTOR_GH_USERNAME" != "null" ]]; then
                        HUMAN_ID="@${REQUESTOR_GH_USERNAME}"
                      else
                         HUMAN_ID="automation via Harness IDP"
                      fi

                      # Build metadata block
                      META_BLOCK=$'\n\n## üß© IDP Context (auto-added by pipeline)\n'\
                      "**Requester:** $HUMAN_ID"$'\n'\
                      "**Pipeline:** <+pipeline.identifier> | **Run #:** <+pipeline.sequenceId>"$'\n'\
                      "**Execution URL:** <+pipeline.executionUrl>"$'\n'\
                      "**Feature Branch:** \`$HEAD\` --> **Target Branch:** \`$BASE\`."

                      # Combine PR template (if exists) + metadata into body
                      TEMPLATE_PATH="$REPO_DIR/.github/pull_request_template.md"
                      COMBINED="/tmp/combined_body.md"

                      if [[ -f "$TEMPLATE_PATH" ]]; then
                        cat "$TEMPLATE_PATH" > "$COMBINED"
                        printf "%s" "$META_BLOCK" >> "$COMBINED"
                      else
                        printf "%s" "$META_BLOCK" > "$COMBINED"
                      fi

                      # Labels to help triage
                      LABELS=(--label idp --label scaffold --label automation)
                      [[ "${TESTING}" == "yes" ]] && LABELS+=(--label testing)

                      # Check for existing PR from HEAD->BASE
                      EXIST_JSON="$(gh pr list --repo "$OWNER/$REPO" --head "$OWNER:$HEAD" --state open --json number,url 2>/dev/null || echo '[]')"
                      COUNT="$(echo "$EXIST_JSON" | jq 'length')"

                      ASSIGN_FLAGS=()
                      if [[ -n "$REQUESTOR_GH_USERNAME" && "$REQUESTOR_GH_USERNAME" != "null" ]]; then
                        ASSIGN_FLAGS+=(--assignee "$REQUESTOR_GH_USERNAME" --reviewer "$REQUESTOR_GH_USERNAME")
                      fi

                      if [[ "$COUNT" -gt 0 ]]; then
                        PR_NUMBER="$(echo "$EXIST_JSON" | jq -r '.[0].number')"
                        PR_URL="$(echo "$EXIST_JSON" | jq -r '.[0].url')"
                        echo "‚ÑπÔ∏è PR already exists: $PR_URL"

                        # Ensure labels include testing when applicable
                        LABEL_EDIT="idp,scaffold,automation"
                        if [[ "${TESTING}" == "yes" ]]; then
                          LABEL_EDIT+=",testing"
                        fi
                        gh pr edit "$PR_NUMBER" --repo "$OWNER/$REPO" --add-label "$LABEL_EDIT" || true

                        # Visibility ping
                        if [[ -n "$REQUESTOR_GH_USERNAME" && "$REQUESTOR_GH_USERNAME" != "null" ]]; then
                          gh pr comment "$PR_NUMBER" --repo "$OWNER/$REPO" --body "Looping in @$REQUESTOR_GH_USERNAME for visibility." || true
                        else
                          gh pr comment "$PR_NUMBER" --repo "$OWNER/$REPO" --body "PR opened by automation." || true
                        fi

                        PR_STATE="$(gh pr view --repo "$OWNER/$REPO" "$PR_NUMBER" --json state --jq .state)"
                      else
                        echo "Creating PR with gh CLI‚Ä¶"
                        gh pr create --repo "$OWNER/$REPO" \
                          --base "$BASE" --head "$HEAD" \
                          --title "$TITLE" --body-file "$COMBINED" \
                          "${LABELS[@]}" "${ASSIGN_FLAGS[@]}"

                        PR_NUMBER="$(gh pr view --repo "$OWNER/$REPO" "$HEAD" --json number --jq .number)"
                        PR_URL="https://github.com/$OWNER/$REPO/pull/$PR_NUMBER"
                        PR_STATE="$(gh pr view --repo "$OWNER/$REPO" "$HEAD" --json state --jq .state)"
                        echo "‚úÖ Opened PR: $PR_URL"
                      fi

                      export PR_URL PR_NUMBER PR_STATE
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                    outputVariables:
                      - name: PR_URL
                      - name: PR_NUMBER
                      - name: PR_STATE
          cloneCodebase: false
          caching:
            enabled: false
            paths: []
          buildIntelligence:
            enabled: false
        tags: {}
    - stage:
        name: ServiceNow Approval
        identifier: ServiceNow_Approval
        description: ""
        type: Approval
        spec:
          execution:
            steps:
              - step:
                  name: Create ServiceNow Change
                  identifier: Create_ServiceNow_Change
                  type: ServiceNowCreate
                  timeout: 5m
                  spec:
                    connectorRef: account.ServiceNow_Dev
                    ticketType: change_request
                    fields:
                      - name: description
                        value: |
                          Repo: <+pipeline.variables.gh_org>/<+pipeline.variables.base_repo>
                          Branch: <+pipeline.stages.App_Provisioner.spec.execution.steps.Create_Branch.output.outputVariables.BRANCH_NAME>
                          PR: <+pipeline.stages.App_Provisioner.spec.execution.steps.Open_PR.output.outputVariables.PR_URL>
                          Requester: <+pipeline.variables.github_username>
                          Env: <+pipeline.variables.environment_name>                        
                      - name: short_description
                        value: "IDP: <+pipeline.variables.project_slug> to <+pipeline.variables.environment_name> via PR <+pipeline.stages.App_Provisioner.spec.execution.steps.Open_PR.output.outputVariables.PR_NUMBER>"
                    createType: Normal
              - step:
                  type: Container
                  name: Gate the PR
                  identifier: Gate_the_PR
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner
                    command: |
                      set -euo pipefail
                      # Make both gh CLI & curl happy regardless of which var a call expects
                      export GH_TOKEN="<+pipeline.variables.gh_token>"
                      export GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      OWNER="${GH_ORG}"
                      REPO="${MONOREPO_REPO}"
                      PR_NUMBER="<+pipeline.stages.App_Provisioner.spec.execution.steps.Open_PR.output.outputVariables.PR_NUMBER>"
                      CHANGE_ID="<+pipeline.stages.ServiceNow_Approval.spec.execution.steps.Create_ServiceNow_Change.ticket.ticketNumber>"
                      CHANGE_URL="<+pipeline.stages.ServiceNow_Approval.spec.execution.steps.Create_ServiceNow_Change.ticket.ticketUrl>"

                      # Comment for auditability
                      gh pr comment "$PR_NUMBER" -R "$OWNER/$REPO" \
                        --body "üßæ ServiceNow Change **$CHANGE_ID** created. Track it here: $CHANGE_URL"

                      # Normalize state labels (quiet if already/absent)
                      gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --remove-label "change:approved" --remove-label "change:rejected" 2>/dev/null || true
                      gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --add-label "change:pending" 2>/dev/null || true

                      # Mark commit status = PENDING and link to SNOW
                      COMMIT_SHA="$(gh pr view "$PR_NUMBER" -R "$OWNER/$REPO" --json headRefOid --jq .headRefOid)"
                      gh api "repos/$OWNER/$REPO/statuses/$COMMIT_SHA" \
                        -f state="pending" \
                        -f context="servicenow/change-approval" \
                        -f description="Waiting for ServiceNow approval and change window" \
                        -f target_url="$CHANGE_URL"
                    shell: Bash
                    infrastructure:
                      type: KubernetesDirect
                      spec:
                        connectorRef: parsoneks
                        namespace: harness-delegate-ng
                        resources:
                          limits:
                            cpu: "0.5"
                            memory: 500Mi
                        annotations: {}
                        labels: {}
                        containerSecurityContext:
                          capabilities:
                            drop: []
                            add: []
                        nodeSelector: {}
                    reports:
                      type: JUnit
                      spec:
                        paths: []
                    outputVariables: []
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                  timeout: 5m
              - step:
                  type: ServiceNowApproval
                  name: Wait for ServiceNow Approval
                  identifier: Wait_for_ServiceNow_Approval
                  spec:
                    connectorRef: account.ServiceNow_Dev
                    ticketNumber: <+pipeline.stages.ServiceNow_Approval.spec.execution.steps.Create_ServiceNow_Change.ticket.ticketNumber>
                    retryInterval: 1m
                    ticketType: change_request
                    approvalCriteria:
                      type: KeyValues
                      spec:
                        matchAnyCondition: true
                        conditions:
                          - key: state
                            operator: in
                            value: Implement
                    rejectionCriteria:
                      type: KeyValues
                      spec:
                        matchAnyCondition: true
                        conditions:
                          - key: state
                            operator: in
                            value: Canceled
                  timeout: 2m
                  failureStrategies:
                    - onFailure:
                        errors:
                          - Timeout
                        action:
                          type: Ignore
              - step:
                  type: Container
                  name: Update PR Check
                  identifier: Update_PR_Check
                  spec:
                    registryRef: parson
                    image: parsontodd/harness-custom-runner
                    command: |
                      set -euo pipefail

                      # Make both gh CLI & curl happy regardless of which var a call expects
                      export GH_TOKEN="<+pipeline.variables.gh_token>"
                      export GITHUB_TOKEN="<+pipeline.variables.gh_token>"

                      OWNER="${GH_ORG}"
                      REPO="${MONOREPO_REPO}"
                      PR_NUMBER="<+pipeline.stages.App_Provisioner.spec.execution.steps.Open_PR.output.outputVariables.PR_NUMBER>"
                      COMMIT_SHA="$(gh pr view "$PR_NUMBER" -R "$OWNER/$REPO" --json headRefOid --jq .headRefOid)"
                      STEP_STATUS="${SERVICE_NOW_STATUS}"

                      # small helper to avoid noisy errors
                      has_label() { gh pr view "$PR_NUMBER" -R "$OWNER/$REPO" --json labels --jq '.labels[].name' | grep -qx "$1"; }

                      case "$STEP_STATUS" in
                        success|Success|SUCCEEDED|Succeeded|PASSED|Passed|IGNORE_FAILED|Ignore_Failed)
                          GH_STATE="success"; DESC="ServiceNow change approved and within window"
                          has_label "change:pending" && gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --remove-label "change:pending" || true
                          gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --add-label "change:approved" || true
                          ;;
                        *)
                          GH_STATE="failure"; DESC="ServiceNow change rejected or canceled"
                          has_label "change:pending" && gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --remove-label "change:pending" || true
                          gh pr edit "$PR_NUMBER" -R "$OWNER/$REPO" --add-label "change:rejected" || true
                          ;;
                      esac

                      gh api "repos/$OWNER/$REPO/statuses/$COMMIT_SHA" \
                        -f state="$GH_STATE" \
                        -f context="servicenow/change-approval" \
                        -f description="$DESC"
                    shell: Bash
                    infrastructure:
                      type: KubernetesDirect
                      spec:
                        connectorRef: parsoneks
                        namespace: harness-delegate-ng
                        resources:
                          limits:
                            cpu: "0.5"
                            memory: 500Mi
                        annotations: {}
                        labels: {}
                        containerSecurityContext:
                          capabilities:
                            drop: []
                            add: []
                        nodeSelector: {}
                    reports:
                      type: JUnit
                      spec:
                        paths: []
                    outputVariables: []
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      SERVICE_NOW_STATUS: <+pipeline.stages.ServiceNow_Approval.spec.execution.steps.Wait_for_ServiceNow_Approval.status>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                    connectorRef: parsondocker
                  timeout: 5m
              - step:
                  type: Container
                  name: Register Component
                  identifier: Register_Component
                  spec:
                    connectorRef: parsondocker
                    image: parsontodd/harness-custom-runner:latest
                    command: |-
                      set -euo pipefail

                      # ========================= Preflight ===================================
                      gh --version   >/dev/null || { echo "gh missing";  exit 1; }
                      jq --version   >/dev/null || { echo "jq missing";  exit 1; }
                      curl --version >/dev/null || { echo "curl missing"; exit 1; }
                      if command -v git >/dev/null 2>&1; then
                        git config --global --add safe.directory '*' || true
                      fi

                      # ========================= Inputs ======================================
                      ACCOUNT_ID="${ACCOUNT_ID:?ACCOUNT_ID required}"             # <+account.identifier>
                      OWNER="${GH_ORG:?GH_ORG required}"                          # from Derive_Vars
                      REPO="${MONOREPO_REPO:?MONOREPO_REPO required}"            # from Derive_Vars
                      DEFAULT="${DEFAULT_BRANCH:?DEFAULT_BRANCH required}"        # from Derive_Vars
                      PROJECT_SLUG="${PROJECT_SLUG:?PROJECT_SLUG required}"      # from Derive_Vars
                      PR_NUMBER="${PR_NUMBER:?PR_NUMBER required}"                # from Open_PR output

                      # Auth
                      X_API_KEY="${X_API_KEY:?X_API_KEY (Harness API key) required}"
                      GH_TOKEN="${GH_TOKEN:-${GITHUB_TOKEN:-}}"

                      # Harness Entities Import endpoint (Platform API)
                      ENTITIES_IMPORT_API="https://app.harness.io/v1/entities/import"

                      # We assume your file path pattern: <project_slug>/catalog-info.yaml
                      # Override with FILE_PATH if needed.
                      FILE_PATH="${FILE_PATH:-${PROJECT_SLUG}/catalog-info.yaml}"
                      BRANCH_NAME="${BRANCH_NAME:-${DEFAULT}}"
                      CONNECTOR_REF="${CONNECTOR_REF:-account.harnessgithub}"
                      IS_HARNESS_CODE_REPO="${IS_HARNESS_CODE_REPO:-false}"

                      # Convenience URLs to test file presence
                      BLOB_URL="https://github.com/${OWNER}/${REPO}/blob/${BRANCH_NAME}/${FILE_PATH}?raw=1"
                      RAW_URL="https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH_NAME}/${FILE_PATH}"

                      echo "PR_NUMBER=${PR_NUMBER}"
                      echo "OWNER=${OWNER} REPO=${REPO}"
                      echo "FILE_PATH=${FILE_PATH} BRANCH_NAME=${BRANCH_NAME}"

                      # ====================== 1) Wait for PR merge ===========================
                      echo "üîé Waiting for PR #${PR_NUMBER} to be merged (repo ${OWNER}/${REPO})"
                      MAX_WAIT_SEC=$((30*60)); SLEEP_SEC=10; waited=0

                      while :; do
                        pr_json="$(curl -fsS -H "Authorization: token ${GH_TOKEN}" \
                          "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}")" || {
                            echo "‚ùå Failed to fetch PR details."; exit 20; }

                        state="$(echo "$pr_json" | jq -r '.state // "unknown"')"   # open/closed
                        merged="$(echo "$pr_json" | jq -r '.merged // false')"     # true/false
                        echo "   state=${state} merged=${merged}"

                        if [[ "$merged" == "true" ]]; then
                          echo "‚úÖ PR is merged."
                          break
                        fi
                        if [[ "$state" == "closed" ]]; then
                          echo "‚ùå PR closed without merge ‚Äî aborting registration."
                          exit 23
                        fi

                        (( waited >= MAX_WAIT_SEC )) && { echo "‚ùå Timeout waiting for PR merge."; exit 21; }
                        sleep "${SLEEP_SEC}"; waited=$((waited + SLEEP_SEC))
                      done

                      # ========== 2) Wait for catalog-info.yaml on the target branch =========
                      echo "üîé Waiting for ${FILE_PATH} on ${BRANCH_NAME}‚Ä¶"
                      waited=0
                      TARGET_URL="${BLOB_URL}"
                      while :; do
                        blob_head="$(curl -s -o /dev/null -w '%{http_code}' -H "Authorization: token ${GH_TOKEN}" "${TARGET_URL}")"
                        if [[ "${blob_head}" == "200" ]]; then
                          echo "‚úÖ Found via blob URL."
                          break
                        fi
                        raw_head="$(curl -s -o /dev/null -w '%{http_code}' -H "Authorization: token ${GH_TOKEN}" "${RAW_URL}")"
                        if [[ "${raw_head}" == "200" ]]; then
                          TARGET_URL="${RAW_URL}"
                          echo "‚úÖ Found via raw URL."
                          break
                        fi
                        (( waited >= MAX_WAIT_SEC )) && { echo "‚ùå Timeout waiting for ${FILE_PATH} (blob=${blob_head}, raw=${raw_head})."; exit 22; }
                        sleep "${SLEEP_SEC}"; waited=$((waited + SLEEP_SEC))
                      done
                      echo "üìÑ Target YAML: ${TARGET_URL}"

                      # =================== 3) Import the entity from Git =====================
                      echo "üöö Importing entity from Git via ${ENTITIES_IMPORT_API}"
                      payload="$(jq -n \
                        --arg connector_ref "${CONNECTOR_REF}" \
                        --arg repo_name     "${REPO}" \
                        --arg branch_name   "${BRANCH_NAME}" \
                        --arg file_path     "${FILE_PATH}" \
                        --argjson is_harness_code_repo "${IS_HARNESS_CODE_REPO}" '
                        {
                          connector_ref: $connector_ref,
                          repo_name: $repo_name,
                          branch_name: $branch_name,
                          file_path: $file_path,
                          is_harness_code_repo: $is_harness_code_repo
                        }'
                      )"

                      http_code="$(
                        curl -sS -o /tmp/idp_resp.json -w '%{http_code}' \
                          -X POST "${ENTITIES_IMPORT_API}" \
                          -H "Content-Type: application/json" \
                          -H "x-api-key: ${X_API_KEY}" \
                          -H "Harness-Account: ${ACCOUNT_ID}" \
                          --data "${payload}"
                      )"

                      case "${http_code}" in
                        200|201|202|409)
                          echo "‚úÖ Entities import acknowledged (HTTP ${http_code})."
                          ;;
                        *)
                          echo "‚ùå Entities import failed (HTTP ${http_code}). Response:"
                          cat /tmp/idp_resp.json || true
                          exit 1
                          ;;
                      esac

                      # ============== 4) Parse helpful fields & export outputs ===============
                      ENTITY_REF="$(jq -r '.entityRef // .entities[0].entityRef // empty' /tmp/idp_resp.json || true)"
                      ORG_ID="$(jq -r '.orgIdentifier // empty' /tmp/idp_resp.json || true)"
                      PROJ_ID="$(jq -r '.projectIdentifier // empty' /tmp/idp_resp.json || true)"
                      KIND="$(jq -r '.kind // .entities[0].kind // empty' /tmp/idp_resp.json || true)"
                      IDENTIFIER="$(jq -r '.identifier // .entities[0].identifier // empty' /tmp/idp_resp.json || true)"

                      echo "entityRef: ${ENTITY_REF:-<unknown>}"
                      echo "kind:      ${KIND:-<unknown>}"
                      echo "id:        ${IDENTIFIER:-<unknown>}"
                      echo "org:       ${ORG_ID:-<unknown>}  project: ${PROJ_ID:-<unknown>}"

                      if [[ -n "${ORG_ID}" && -n "${PROJ_ID}" && -n "${KIND}" && -n "${IDENTIFIER}" ]]; then
                        CATALOG_URL="https://app.harness.io/ng/account/${ACCOUNT_ID}/module/idp/catalog/account.${ORG_ID}.${PROJ_ID}/${KIND}/${IDENTIFIER}"
                        echo "üîó Catalog: ${CATALOG_URL}"
                        export CATALOG_URL ENTITY_REF
                      fi
                    shell: Bash
                    infrastructure:
                      type: KubernetesDirect
                      spec:
                        connectorRef: parsoneks
                        namespace: harness-delegate-ng
                        resources:
                          limits:
                            cpu: "0.5"
                            memory: 500Mi
                        annotations: {}
                        labels: {}
                        containerSecurityContext:
                          capabilities:
                            drop: []
                            add: []
                        nodeSelector: {}
                    reports:
                      type: JUnit
                      spec:
                        paths: []
                    outputVariables:
                      - name: CATALOG_URL
                      - name: CATALOG_HTTP
                      - name: LOCATION_ID
                      - name: ENTITY_REF
                    envVariables:
                      GH_ORG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GH_ORG>
                      MONOREPO_REPO: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.MONOREPO_REPO>
                      DEFAULT_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.DEFAULT_BRANCH>
                      FEATURE_BRANCH: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.FEATURE_BRANCH>
                      PROJECT_SLUG: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_SLUG>
                      OWNER_TEAM: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.OWNER_TEAM>
                      REQUESTOR_GH_USERNAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.REQUESTOR_GH_USERNAME>
                      TESTING: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.TESTING>
                      GIT_AUTHOR_NAME: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_NAME>
                      GIT_AUTHOR_EMAIL: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.GIT_AUTHOR_EMAIL>
                      SERVICE_NOW_STATUS: <+pipeline.stages.ServiceNow_Approval.spec.execution.steps.Wait_for_ServiceNow_Approval.status>
                      PROJECT_OWNER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Derive_Vars.output.outputVariables.PROJECT_OWNER>
                      ACCOUNT_ID: <+account.identifier>
                      X_API_KEY: <+secrets.getValue('parson-api')>
                      PR_NUMBER: <+pipeline.stages.App_Provisioner.spec.execution.steps.Open_PR.output.outputVariables.PR_NUMBER>
                      GH_TOKEN: <+pipeline.variables.gh_token>
                      GITHUB_TOKEN: <+pipeline.variables.gh_token>
                  timeout: 35m
                  when:
                    stageStatus: Success
                    condition: <+pipeline.variables.register_component> == "true"
        tags: {}
        delegateSelectors:
          - parson-eks-delegate
  variables:
    - name: project_name
      type: String
      description: ""
      required: false
      value: <+input>
    - name: project_slug
      type: String
      description: ""
      required: false
      value: <+pipeline.variables.project_name.toLowerCase().replace(" ", "-")>
    - name: project_owner
      type: String
      description: ""
      required: false
      value: <+input>.default(todd.parson@harness.io)
    - name: project_name_sanitized
      type: String
      description: ""
      required: false
      value: <+pipeline.variables.project_name.toLowerCase().replace(" ", "-")>
    - name: project_description
      type: String
      description: ""
      required: false
      value: <+input>.default(Testing for POC)
    - name: gh_org
      type: String
      description: ""
      required: false
      value: <+input>.default(harness-idp-sandbox)
    - name: default_branch
      type: String
      description: ""
      required: false
      value: <+input>.default(main)
    - name: base_repo
      type: String
      description: ""
      required: false
      value: <+input>.default(monorepo-idp-example)
    - name: new_branch_prefix
      type: String
      description: ""
      required: false
      value: <+input>.default(feature)
    - name: environment_name
      type: String
      description: ""
      required: false
      value: <+input>.default(dev)
    - name: aws_region
      type: String
      description: ""
      required: false
      value: <+input>.default(us-east-1)
    - name: enable_jira
      type: String
      description: ""
      required: false
      value: <+input>.default(false).selectOneFrom(true,false)
    - name: github_username
      type: String
      value: <+input>.default("")
    - name: testing
      type: String
      description: Toggle to test without triggering GitHub Actions
      required: false
      value: <+input>.default(no).selectOneFrom(yes,no)
    - name: enforce_requestor_access
      type: String
      description: Enforce requester repo access (yes=fails pipeline if no write)
      required: false
      value: <+input>.default(yes).selectOneFrom(yes,no)
    - name: gh_token
      type: Secret
      value: parson-gh-pat
    - name: github_team
      type: String
      description: ""
      required: false
      value: platform-team
    - name: connector_ref
      type: String
      description: The Harness GitHub Connector Identifier used to register the catalog component
      required: false
      value: <+input>.default(IDP_GitHub_Sandbox_for_Testing)
    - name: register_component
      type: String
      description: Automatically register the component in the IDP Catalog?
      required: false
      value: <+input>.default(false).selectOneFrom(true,false)
